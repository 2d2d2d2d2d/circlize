% \VignetteIndexEntry{circlize}
% \VignetteDepends{circlize}
% \VignetteKeywords{circos}
% \VignetteKeywords{ideogram}
% \VignetteKeywords{circlize}
% \VignettePackage{circlize}

\documentclass{article}

\title{A brief introduction of the {\tt circlize} package}

\author{Zuguang Gu\\ German Cancer Research Center,\\ Heidelberg, Germany}

\usepackage{Sweave}
\usepackage{hyperref}

\begin{document}

\maketitle 

\section{Introduction}
Circos layout (\url{http://circos.ca}) is very useful to represent complicated informations, especially for genomic data.
The {\tt circlize} package implements the circos layout in R. The package allocates
and illustrates data in a certain category into a cell inside a circle and makes you
felling that you are plotting figures in a normal plotting coordinate.

Since most of the figures are composed of points, lines and polygon (for filled color),
so we just need to implement functions for drawing points, lines and polygon.

Current there are following functions that can be used for plotting:

\begin{itemize}
  \item {\tt circos.points}
  \item {\tt circos.lines}
  \item {\tt circos.rect}
  \item {\tt circos.polygon}
  \item {\tt circos.text}
  \item {\tt circos.axis}
  \item {\tt circos.link}, This maybe the unique feature for circos layout to represent relationships between elements.
\end{itemize}

For drawing points, lines and text through the whole track (among several sectors), the following functions are available:

\begin{itemize}
  \item {\tt circos.trackPoints}
  \item {\tt circos.trackLines}
  \item {\tt circos.trackText}
\end{itemize}

Also, the function drawing histograms in the whole track is available:

\begin{itemize}
  \item {\tt circos.trackHist}
\end{itemize}

Functions to arrange the circos layout

\begin{itemize}
  \item {\tt circos.trackPlotRegion}
  \item {\tt circos.updatPlotRegion}
  \item {\tt circos.par}
  \item {\tt circos.clear}
\end{itemize}

Theoretically, you are able to draw most kinds of circos figures by the above functions.

Following is an example. First generate some data. There are a factor to represent categories,
x-values, and y-values.

\begin{Schunk}
\begin{Sinput}
> set.seed(12345)
> n = 10000
> a = data.frame(factor = sample(letters[1:8], n, replace = TRUE),
+     x = rnorm(n), y = runif(n))
\end{Sinput}
\end{Schunk}

Initialize the layout. In this step, the function allocates sectors along
the unit circle according to ranges of x-values in different categories.
Here we only need x-values because all cells in a sector share the same
x-ranges.

\begin{Schunk}
\begin{Sinput}
> library(circlize)
> par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.7)
> circos.par("default.track.height" = 0.1)
> circos.initialize(factors = a$factor, x = a$x)
\end{Sinput}
\end{Schunk}

Draw the first track. All the tracks should be created by {\tt circos.trackPlotRegion}, then
those low level function can be applied. Here we should specify the y-values either by {\tt y}
or {\tt ylim} argument. The axis for each cell is drawn by {\tt panel.fun} argument. The {\tt panel.fun}
is actually executed after the creation of the plotting region for a cell. Then draw points
through the whole track by {\tt circos.trackPoints}. Finally, add two texts in a certain cell.

\begin{Schunk}
\begin{Sinput}
> circos.trackPlotRegion(factors = a$factor, y = a$y,
+     panel.fun = function(x, y) {
+         circos.axis()
+ })
> circos.trackPoints(a$factor, a$x, a$y, col = col,
+     pch = 16, cex = 0.5)
> circos.text(-1, 0.5, "left", sector.index = "a")
> circos.text(1, 0.5, "right", sector.index = "a")
\end{Sinput}
\end{Schunk}

Draw the second track. It is histograms among the track. The {\tt circos.trackHist}
can also create a new track.

\begin{Schunk}
\begin{Sinput}
> circos.trackHist(a$factor, a$x, bg.col = bgcol, col = NA)
\end{Sinput}
\end{Schunk}

Draw the third track. Different background colors for cells can be assigned.

\begin{Schunk}
\begin{Sinput}
> circos.trackPlotRegion(factors = a$factor, x = a$x, y = a$y,
+   panel.fun = function(x, y) {
+       grey = c("#FFFFFF", "#CCCCCC", "#999999")
+       i = get.cell.meta.data("sector.numeric.index")
+       circos.updatePlotRegion(bg.col = grey[i %% 3 + 1])
+       circos.points(x[1:10], y[1:10], col = "red", pch = 16, cex = 0.6)
+       circos.points(x[11:20], y[11:20], col = "blue", cex = 0.6)
+   })
\end{Sinput}
\end{Schunk}

Update an existed cell.

\begin{Schunk}
\begin{Sinput}
> circos.updatePlotRegion(sector.index = "d", track.index = 2)
> circos.points(x = runif(100), y = runif(100))
\end{Sinput}
\end{Schunk}

Draw the fouth track.
\begin{Schunk}
\begin{Sinput}
> circos.trackPlotRegion(factors = a$factor, y = a$y)
> circos.trackLines(a$factor[1:100], a$x[1:100], a$y[1:100], type = "h")
\end{Sinput}
\end{Schunk}

Draw links. Links can be from point to point, point to interval or interval to interval.

\begin{Schunk}
\begin{Sinput}
> circos.link("a", 0, "b", 0, top.ratio = 0.9)
> circos.link("c", c(-0.5, 0.5), "d", c(-0.5,0.5), col = "red",
+     border = "blue", top.ratio = 0.2)
> circos.link("e", 0, "g", c(-1,1), col = "green", lwd = 2, lty = 2)
\end{Sinput}
\end{Schunk}


<<label=figexample, include=FALSE, echo=FALSE>>=
library(circlize)
set.seed(12345)
n = 10000
a = data.frame(factor = sample(letters[1:8], n, replace = TRUE), x = rnorm(n), y = runif(n))
for(le in levels(a$factor)) {
    a$x[a$factor == le] = a$x[a$factor == le] * runif(1)
}

par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.7)
circos.par("default.track.height" = 0.1)
circos.initialize(factors = a$factor, x = a$x)

bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
col = rep(c("#FF000010", "#00FF0010"), 4)
circos.trackPlotRegion(factors = a$factor, y = a$y, panel.fun = function(x, y) {
	circos.axis()
})
circos.trackPoints(a$factor, a$x, a$y, col = col, pch = 16, cex = 0.5)
circos.text(-1,0.5, "left", sector.index = "a")
circos.text(1,0.5, "right", sector.index = "a")

circos.trackHist(a$factor, a$x, bg.col = bgcol, col = NA)

circos.trackPlotRegion(factors = a$factor, x = a$x, y = a$y, panel.fun = function(x, y) {
    grey = c("#FFFFFF", "#CCCCCC", "#999999")
	i = get.cell.meta.data("sector.numeric.index")
    circos.updatePlotRegion(bg.col = grey[i %% 3 + 1])
    circos.points(x[1:10], y[1:10], col = "red", pch = 16, cex = 0.6)
    circos.points(x[11:20], y[11:20], col = "blue", cex = 0.6)
})

circos.updatePlotRegion(sector.index = "d", track.index = 2)
circos.points(x = runif(100), y = runif(100))

circos.trackPlotRegion(factors = a$factor, y = a$y)
circos.trackLines(a$factor[1:100], a$x[1:100], a$y[1:100], type = "h")

circos.link("a", 0, "b", 0, top.ratio = 0.9)
circos.link("c", c(-0.5, 0.5), "d", c(-0.5,0.5), col = "red", border = "blue", top.ratio = 0.2)
circos.link("e", 0, "g", c(-1,1), col = "green", lwd = 2, lty = 2)

circos.clear()
@

\begin{figure}
\begin{center}
<<label=figexample, fig = TRUE, echo = FALSE>>=
<<figexample>>
@
\end{center}
\caption{An example for circos layout}
\label{fig:example}
\end{figure}


The final figure looks like figure 1.

<<label=figtransformation, include=FALSE, echo=FALSE>>=
library(circlize)
layout(cbind(c(1, 0, 2, 0, 3)), height = c(2,0.5,2, 0.5, 4))
par(mar = c(2, 2, 2, 2))
x = 1:10
y = rnorm(10)
plot(x, y, type = "l", axes = FALSE, ann = FALSE)
text(2, 0, "text", cex = 2)
rect(5, -1, 7, 1)
box()
axis(side = 1)

par(mar = c(1, 1, 1, 1))
factors = letters[1:3]
circos.par("canvas.xlim" = c(-sqrt(3)/2, sqrt(3)/2), "canvas.ylim" = c(1/2*0.6, 1), start.degree = 30, "track.margin" = c(0, 0), "gap.degree" = 0, "clock.wise" = FALSE)
circos.initialize(factors = factors, xlim = c(1, 10))
circos.trackPlotRegion(factors = factors, ylim = range(y), track.height = 0.4, bg.border = NA)
circos.updatePlotRegion(sector.index = "a", track.index = 1, bg.border = "black")
circos.lines(x, y, sector.index = "a", track.index = 1, straight = TRUE)
circos.text(2, 0, "text", cex = 2)
circos.rect(5, -1, 7, 1)
circos.axis(h = "bottom")
circos.clear()

par(xpd = NA)
arrows(0, 1.33, 0, 1.07, code = 2)

par(mar = c(3, 3, 3, 3))
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(1, 10))
circos.trackPlotRegion(factors = factors, ylim = range(y), track.height = 0.4)
circos.updatePlotRegion(sector.index = "c", track.index = 1, bg.border = "black")
circos.lines(x, y, sector.index = "c", track.index = 1, straight = TRUE)
circos.text(2, 0, "text", cex = 2)
circos.rect(5, -1, 7, 1)
circos.axis(h = "bottom")
circos.clear()
box()
axis(side = 1)
axis(side = 2)
arrows(0, 1.5, 0, 1.07, code = 2)
@

\begin{figure}
\begin{center}
<<label=figtransformation, fig = TRUE, echo = FALSE, height=8.5, width=4>>=
<<figtransformation>>
@
\end{center}
\caption{Transformation between different coordinates}
\label{fig:transformation}
\end{figure}

\section{Rules to draw the circos layout}
The rules for drawing the circos layout is simple.

\begin{enumerate}
  \item Initialize the layout using {\tt circos.initialize}. There should be a factor and a x-range.
  \item Create plotting regions for the next track, and apply plottings. There
        are three ways to do the plotting job.
		\begin{enumerate}
		    \item After the creation of the track. use function like {\tt circos.points},
			      {\tt circos.lines}, ... to draw graphs cell by cell. It allways involves
				  a {\tt for} loop.
			\item Use {\tt circis.trackPoints}, {\tt circos.trackLines}, ... to draw same style
			      of graphs through cells simultaneously. However, it is not recommended because
				  it would make you a little confused.
			\item Use {\tt panel.fun} argument in {\tt circos.trackPlotRegion} to draw
			      graphs immediately after the creation of certain cell.
		\end{enumerate}
		Plotting regions for cells that have been created can be updated by {\tt circos.updatePlotRegion}.
		{\tt circos.updatePlotRegion} will erase every that you have already plotted in the plotting region of the cell.
  \item Call {\tt circos.clear} to do cleanings.
\end{enumerate}

There is a internal variable keep tracing of the current sector and track when applying {\tt circos.trackPlotRegion} and {\tt circos.updatePlotRegion}.
So although functions like {\tt circos.points}, {\tt circos.lines} need to specify the index for sector and track,
the values for sector index and the track index, by default, are taken as the current calculated ones. As a result,
if you draw points, lines, text, ... just after the creation of the track or cell, you do not need to set the sector
index and the track index explicitly and it is just drawn in the most nearly created cell.

\section{Coordinate transformation}
There is a user coordinate in which the range for x-axis and y-axis is the range of data,
a polar coordinate to allocates different cells and a the canvas coordinate which really
draw the figures (figure 2). The package would first transform the user
coordinate to a polar coordinate and finally transform into the canvas coordinate.

The finnal canvas coordinate is in fact an ordinary plotting in R plotting system with
x-range from -1 to 1 and y-range from -1 to 1 by defaulte.

{\bf It should be noted that the circos layout is always drawn inside the circle which has radius of 1 (unit
circle), from outside to inside. }

<<label=figcoordinate, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = factor(letters[1:10], levels = sample(letters[1:10], 10))
circos.par("cell.padding" = c(0, 0, 0, 0))
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
for(l in letters[1:10]) {
	circos.rect(0,0,10,10,sector.index = l, track.index = 2, col = "#FF000040")
}

for(l in 1:4) {
	circos.rect(0,0,10,10,sector.index = "a", track.index = l, col = "#0000FF40")
}
show.index()
circos.clear()

@

\begin{figure}
\begin{center}
<<label=figcoordinate, fig = TRUE, echo = FALSE>>=
<<figcoordinate>>
@
\end{center}
\caption{Coordinate in circos layout}
\label{fig:coordinate}
\end{figure}


\section{Sectors and tracks}
A circos layout is composed of sectors and tracks, as illustrated in figure 3.
The red circle is the track and the blue one is the sector. The intersection of a sector and 
a track is called a cell which can be thought as an imaginary plotting region for values in certain category. 
Order of the sectors are determined by the order of levels of the factor
when initializing and the order of the tracks are integers starting from the most outside track as 1.
Width of sectors are allocated according to the range of x-values in different categories. All cells
in one sector in different tracks share the same x-ranges.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.99\textwidth]{region.pdf}
\caption{Regions for a cell}
\label{region}
\end{center}
\end{figure}


<<label=figdirection, include=FALSE, echo=FALSE>>=
par(mfrow = c(2, 1))
par(mar = c(1, 1, 1, 1))
factors = letters[1:8]
circos.initialize(factors = factors, xlim = c(0, 10))
circos.par("track.margin" = c(0.1, 0.1))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.4, panel.fun = function(x, y) {
	circos.text(5, 5, get.cell.meta.data("sector.index"))
	xlim = get.cell.meta.data("xlim")
	ylim = get.cell.meta.data("ylim")
	circos.lines(xlim, c(0, 0))
	circos.lines(c(9, 10), c(0.5, 0))
	circos.lines(c(9, 10), c(-0.5, 0))
	circos.lines(c(0, 0), xlim)
	circos.lines(c(0.5, 0), c(9, 10))
	circos.lines(c(-0.5, 0), c(9, 10))
})
circos.clear()

x = seq(-0.7, 0.7, length = 100)
d = cbind(x, sqrt(1 - x^2))
lines(d)
arrows(d[2,1], d[2,2], d[1,1], d[1,2])

x = seq(-0.7, 0.7, length = 100)
d = cbind(x, -sqrt(1 - x^2))
lines(d)
arrows(d[99,1], d[99,2], d[100,1], d[100,2])

text(0, 0, 'circos.par("clock.wise" = FALSE)', cex = 0.6)

par(mar = c(1, 1, 1, 1))
factors = letters[1:8]
circos.par("track.margin" = c(0.1, 0.1), clock.wise = TRUE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.4, panel.fun = function(x, y) {
	circos.text(5, 5, get.cell.meta.data("sector.index"))
	xlim = get.cell.meta.data("xlim")
	ylim = get.cell.meta.data("ylim")
	circos.lines(xlim, c(0, 0))
	circos.lines(c(9, 10), c(0.5, 0))
	circos.lines(c(9, 10), c(-0.5, 0))
	circos.lines(c(0, 0), xlim)
	circos.lines(c(0.5, 0), c(9, 10))
	circos.lines(c(-0.5, 0), c(9, 10))
})
circos.clear()

x = seq(-0.7, 0.7, length = 100)
d = cbind(x, sqrt(1 - x^2))
lines(d)
arrows(d[99,1], d[99,2], d[100,1], d[100,2])


x = seq(-0.7, 0.7, length = 100)
d = cbind(x, -sqrt(1 - x^2))
lines(d)
arrows(d[2,1], d[2,2], d[1,1], d[1,2])
text(0, 0, 'circos.par("clock.wise" = TRUE)', cex = 0.6)
@

\begin{figure}
\begin{center}
<<label=figdirection, fig = TRUE, echo = FALSE, width=4, height=8>>=
<<figdirection>>
@
\end{center}
\caption{Sector directions}
\label{fig:direction}
\end{figure}


\section{Circos parameters}
Some basic parameters for the circos layout can be set through {\tt circos.par}. The paramters
are as follows, note some parameters can only be assigned before the initialization of the circos layout.

\begin{itemize}
	\item {\tt start.degree}: The starting degree which the circle begin to draw. Note this degree is measured 
	      in the standard polar coordinate which means it is anti-clockwise.
	\item {\tt gap.degree}: Gap between two neighbour sectors. Note a gap is allocated first in front of the first sector. See figure 4.
	\item {\tt track.margin}: Like {\tt margin} in Cascading Style Sheets (CSS), it is the blank area
          out of the plotting region, also outside of the borders. Since left and right margin are controlled
          by {\tt gap.degree}, only bottom and top margin need to be set. The value for the {\tt track.margin}
          is the percentage according to the radius of the unit circle. See figure 4.
	\item {\tt cell.padding}: Padding of the cell. Like {\tt padding} in Cascading Style Sheets
          (CSS), it is the blank area around the plotting regions, but within the borders.
          The paramter has four values, which controls the bottom, left, top and right padding
          respectively. The four values are all percentages in which the first and the third padding
          values are the percentages according to the range of values on y-axis and the second and
          fourth values are the percentages according to the range of values on x-axis. See figure 4.
	\item {\tt unit.circoe.segments}: Since curves are simulated by a series of straight lines,
          this parameter controls the amout of segments to represent a curve. The minimal length
          of the line segmentation is the length of the unit circle divided by {\tt unit.circoe.segments}.	 
    \item {\tt default.track.height}: The default height of tracks. It is the percentage according to the radius
          of the unit circle. The height includes the top and bottom cell paddings but not the margins.
          However, the definition would be changed in future version because I think it would be more 
          reasonable to include the margins in the track.
	\item {\tt points.overflow.warning}: Since each cell is in fact not a plotting region but only
          an ordinary rectangle, it does not eliminate points that are plotted out of
          the region. So if some points are out of the plotting region, by default, the 
          package would continue drawing the points and print warnings. But in some 
          circumstances, draw something out of the plotting region is useful, such as draw
          some legend or text. Set this value to {\tt FALSE} to turn off the warnings.
	\item {\tt canvas.xlim}: The coordinate for the canvas. By default, the package draws unit circle, so
          the xlim for the canvas would be {\tt c(-1, 1)}. However, you can set it to a more broad
          interval if you want to draw other things out of the circle. By choose proper
          {\tt canvas.xlim} and {\tt canvas.ylim}, you can draw part of the circle. E.g. setting
          {\tt canvas.xlim} to {\tt c(0, 1)} and {\tt canvas.ylim} to {\tt c(0, 1)} would only draw
          circle in the region of {\tt (0, pi/2)}.
	\item {\tt canvas.ylim}: The coordinate for the canvas.
	\item {\tt clock.wise}: The order of drawing sectors. Default is {\tt TRUE} which means anticlockwise (figure 5).
	      But note that inside each cell, the direction of x-axis is always anticlockwise.
\end{itemize}

<<label=figlines, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:7]
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.5)
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "a")
circos.text(5, 9, "type = 'l'", sector.index = "a")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "b", type = "o")
circos.text(5, 9, "type = 'o'", sector.index = "b")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "c", type = "h")
circos.text(5, 9, "type = 'h'", sector.index = "c")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "d", type = "s")
circos.text(5, 9, "type = 's'", sector.index = "d")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "e", area = TRUE)
circos.text(5, 9, "type = 'l', area = TRUE", sector.index = "e")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "f", type = "o", area = TRUE)
circos.text(5, 9, "type = 'o', area = TRUE", sector.index = "f")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "g", type = "s", area = TRUE)
circos.text(5, 9, "type = 's', area = TRUE", sector.index = "g")
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figlines, fig = TRUE, echo = FALSE>>=
<<figlines>>
@
\end{center}
\caption{Line style settings}
\label{fig:lines}
\end{figure}


\section{Lines}
Parameters for drawing lines by {\tt circos.lines} are similar to {\tt lines} function, 
as illustrated in figure 6. One additional feature is that the areas under lines can be 
specified by {\tt area} argument. Also the base line for the area can be set by {\tt area.baseline}.

Straight lines will be transformed to curves when mapping to the circos layout. Normally, 
curves can be approximated by a series of segmentation of straight lines. With more segmentations,
there would be better approximations, but with larger size if you generate the graph as pdf format, especially
if you want to huge genomic data. So, in this package, the number of the segmentation can be controlled by {\tt circos.par("unit.circoe.segments")}.
The length of minimal segment is the length of circumference of the unit circle divided by 
{\tt circos.par(unit.circoe.segments)}. If you do not so such curve-transformations (such as some
radical lines), you can set {\tt straight} argument to {\tt TRUE}. 

<<label=figtext, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.5, panel.fun = function(x, y) {
	circos.text(5, 9, "default_default", direction = "default")
	circos.text(0, 5, "vertical_left", direction = "vertical_left")
	circos.text(10, 5, "vertical_right", direction = "vertical_right")
	circos.text(5, 5, "horizontal", direction = "horizontal")
	circos.text(5, 1, "arc_arc_arc_arc_arc", direction = "arc")
})
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figtext, fig = TRUE, echo = FALSE>>=
<<figtext>>
@
\end{center}
\caption{Text direction settings}
\label{fig:text}
\end{figure}


\section{Text}
Only the direction of text by {\tt circos.text} should be noted, as illustrated in figure 7.
Only five direction of text is allowed which are in {\tt c("default", "vertical\_left", "vertical\_right", "horizontal", "arc")}.


<<label=figaxis, include=FALSE, echo=FALSE>>=
library(circlize)

par(mar = c(1, 1, 1, 1))
factors = letters[1:8]
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.1, bg.border = NA, panel.fun = function(x, y) {
	circos.text(5, 10, get.cell.meta.data("sector.index"))
})

circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.axis(sector.index = "a")
circos.axis(sector.index = "b", direction = "inside")
circos.axis(sector.index = "c", h = "bottom")
circos.axis(sector.index = "d", h = "bottom", direction = "inside")
circos.axis(sector.index = "e", h = 5, major.at = c(1, 3, 5, 7, 9))
circos.axis(sector.index = "f", h = 5, major.at = c(1, 3, 5, 7, 9), labels = c("a", "c", "e", "g", "f"), minor.ticks = 0)
circos.axis(sector.index = "g", h = 5, major.at = c(1, 3, 5, 7, 9), labels = c("a", "c", "e", "g", "f"), major.tick = FALSE)
circos.axis(sector.index = "h", h = 2, major.at = c(1, 3, 5, 7, 9), labels = c("a", "c", "e", "g", "f"), major.tick.percentage = 0.3, labels.away.percentage = 0.2, minor.ticks = 2, labels.direction = "vertical_right")
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figaxis, fig = TRUE, echo = FALSE>>=
<<figaxis>>
@
\end{center}
\caption{Axis settings}
\label{fig:axis}
\end{figure}

\section{Axis}
Because there may be no space to draw y-axis, only x-axis for each cell is supported by {\tt circos.axis}, as illustrated in figure 8.
A lot of styles for axis can be set such as the position and length of major ticks, the number of minor ticks,
the position and direction of the axis labels and the position of the x-axis.


<<label=figlink, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:8]
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.col = "grey", bg.border = NA, track.height = 0.05)

circos.link("a", 5, "c", 5)
circos.link("b", 5, "d", c(4, 6))
circos.link("a", c(2, 3), "f", c(4, 6))

circos.clear()
@

\begin{figure}
\begin{center}
<<label=figlink, fig = TRUE, echo = FALSE>>=
<<figlink>>
@
\end{center}
\caption{Link settings}
\label{fig:link}
\end{figure}



<<label=figquadratic, include=FALSE, echo=FALSE>>=
degree.minus = function(to, from, min.zero = TRUE) {
	if(min.zero) {
		return((to - from) %% 360)
	} else {
		if((to - from) %% 360 == 0) {
			return(360)
		} else {
			return((to - from) %% 360)
		}
	}
}
rotate.parabola = function(theta1, theta2, rou1, rou2 = rou1, theta = (theta1+theta2)/2, 
    rou = rou1 * abs(cos(degree.minus(theta1, theta2)/2/180*pi))*rou.ratio, rou.ratio = 0.5,
    n = 1001) {
    
    while(theta2 < theta1) {
        theta2 = theta2 + 360
    }
    
    delta_theta = degree.minus(theta2, theta1)
    
    flag = 0
    if(delta_theta > 180) {
        theta = theta + 180
        flag = 1
    }
    
    # y^2 = kx, y = +-sqrt(kx)
    b = rou1 * abs(sin(degree.minus(theta2, theta1)/2/180*pi))
    a = rou1 * abs(cos(degree.minus(theta2, theta1)/2/180*pi)) - rou
    k = b^2/a
    
    if(n %% 2 == 0) {
        n = n + 1
    }
    n.half = (n - 1) / 2
    x = numeric(n)
    y = numeric(n)
    x = c(n.half:1/n.half, 0, 1:n.half/n.half)*a
    y[1:n.half] = sqrt(k*x[1:n.half])
    y[n.half + 1] = 0
    y[1:n.half + n.half + 1] = -sqrt(k*x[1:n.half + n.half + 1])
    
    alpha = numeric(n)
    
    alpha[1:n.half] = atan(y[1:n.half]/x[1:n.half])*180/pi
    alpha[1:n.half + n.half + 1] = atan(y[1:n.half + n.half + 1]/x[1:n.half + n.half + 1])*180/pi
    alpha[n.half + 1] = 90
    
    d = sqrt(x^2 + y^2)
    x = d*cos((alpha + theta)/180*pi)
    y = d*sin((alpha + theta)/180*pi)
    
    center.x = rou*cos(theta/180*pi)
    center.y = rou*sin(theta/180*pi)
    
    x = x + center.x
    y = y + center.y
    
    if(!flag) {
        x = rev(x)
        y = rev(y)
    }

    return(cbind(x, y))
}
draw.sector = function (x, y, start=0, end=360, radius, col="black", border = "black") {
    d = NULL
    for (i in 1:500) {
        d = rbind(d, c(start + abs(end - start)/500*i, radius))
    }
    
    m = polar2Cartesian(d)
	if( (end - start) >= 360 || (end - start) %% 360 == 0) {
		
	} else {
		m = rbind(m, c(0, 0))
	}
    m[, 1] = m[, 1] + x
    m[, 2] = m[, 2] + y
    polygon(m, col = col, border = border)
}
polar2Cartesian = function(d) {
    theta = d[, 1]/360 * 2 *pi
    rou = d[, 2]
    x = rou * cos(theta)
    y = rou * sin(theta)
    return(cbind(x, y))
}
par(mar = c(1, 1, 1, 1))
plot(c(-1, 1), c(-1, 1), axes = FALSE, ann = FALSE ,type = "n")
draw.sector(x = 0, y = 0, start = 0, end = 360, radius = 01, col = "white", border = "black")
d= rotate.parabola(theta1 = 270, theta2 = 330, rou1 = 1, rou.ratio = 0.5)
lines(rbind(d, d[1, ]))
lines(c(cos(300/180*pi), cos(120/180*pi)), c(sin(300/180*pi), sin(120/180*pi)))
points(0, 0, pch = 16)
lines(c(0, sqrt(3)/4)+0.01, c(0, -3/4)+0.01, lwd = 4, col = "red")
lines(c(0, sqrt(3)/4/2)-0.01, c(0, -3/4/2)-0.01, lwd = 4, col = "blue")
@

\begin{figure}
\begin{center}
<<label=figquadratic, fig = TRUE, echo = FALSE>>=
<<figquadratic>>
@
\end{center}
\caption{Additional settings for links}
\label{fig:quadratic}
\end{figure}


\section{Links}
Links can be drawn by {\tt circos.link} from points and intervals (figure 9). If both ends are points, then the link is represented
as a line. If one of the ends is an interval, the link would be a belt. The link is in fact a quadratic curve.
The height of the link can be controlled by {\tt top.ratio} argument in {\tt circos.link} which is the ratio between the length of blue line and 
the red line (figure 10). Links do not hold any position of track.

\section{Draw part of the circos layout}
{\tt canvas.xlim} and {\tt canvas.ylim} in {\tt circos.par} is useful to draw only part of circle. Here
only sector between $0^\circ$ to $90^\circ$ are plotted (figure 11). Codes are as follows. First, four sectors
with the same length are initialized. Then only the first sector is drawn with points and lines.

\begin{Schunk}
\begin{Sinput}
> par(mar = c(1, 1, 1, 1))
> circos.par("canvas.xlim" = c(0, 1), "canvas.ylim" = c(0, 1),
+ "clock.wise" = FALSE)
> factors = letters[1:4]
> circos.initialize(factors = factors, xlim = c(0, 1))
> circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
> circos.updatePlotRegion(sector.index = "a", bg.border = "black")
> circos.points(runif(100), runif(100), pch = 16, cex = 0.5)
> circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
> circos.updatePlotRegion(sector.index = "a", bg.border = "black")
> circos.lines(1:100/100, runif(100), pch = 16, cex = 0.5)
> circos.clear()
\end{Sinput}
\end{Schunk}


<<label=figpart, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
circos.par("canvas.xlim" = c(0, 1), "canvas.ylim" = c(0, 1),"clock.wise" = FALSE, "gap.degree" = 0)
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
circos.points(runif(100), runif(100), pch = 16, cex = 0.5)
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
circos.lines(1:100/100, runif(100), pch = 16, cex = 0.5)
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figpart, fig = TRUE, echo = FALSE>>=
<<figpart>>
@
\end{center}
\caption{Part of the circos layout}
\label{fig:part}
\end{figure}

\section{Combine two parts of circos layouts}
Since the circos layout by {\tt circlize} finally plotted in an ordinary R plotting system.
Two seperated circos layouts can be plotted together by some tricks. Here the key is 
{\tt par(new = TRUE)} which allows to draw a new figure on the previous plotting region.

The first example is to draw one outer circos and an inner circos (figure 12).

\begin{Schunk}
\begin{Sinput}
> library(circlize)
> par(mar = c(1, 1, 1, 1))
> factors = letters[1:4]
> circos.initialize(factors = factors, xlim = c(0, 1))
> circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
+     circos.text(0.5, 0.5, "outer circos")
+ })
> circos.clear()
> 
> par(new = TRUE)
> circos.par("canvas.xlim" = c(-2, 2), "canvas.ylim" = c(-2, 2))
> factors = letters[1:3]
> circos.initialize(factors = factors, xlim = c(0, 1))
> circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
+     circos.text(0.5, 0.5, "inner circos")
+ })
> circos.clear()
\end{Sinput}
\end{Schunk}


<<label=fignested, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
	circos.text(0.5, 0.5, "outer circos")
})
circos.clear()

par(new = TRUE)
circos.par("canvas.xlim" = c(-2, 2), "canvas.ylim" = c(-2, 2))
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
	circos.text(0.5, 0.5, "inner circos")
})
circos.clear()
@

\begin{figure}
\begin{center}
<<label=fignested, fig = TRUE, echo = FALSE>>=
<<fignested>>
@
\end{center}
\caption{An outer and an inner circos layout}
\label{fig:nested}
\end{figure}

The second example is to draw to seperated circos layouts in which every
circos only contains a half (figure 13).

\begin{Schunk}
\begin{Sinput}
> library(circlize)
> par(mar = c(1, 1, 1, 1))
> factors = letters[1:4]
> circos.par("canvas.xlim" = c(-1, 1.2), "canvas.ylim" = c(-1, 1.2),
+     start.degree = -45)
> circos.initialize(factors = factors, xlim = c(0, 1))
> circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
> circos.updatePlotRegion(sector.index = "b")
> circos.text(0.5, 0.5, "first one")
> circos.updatePlotRegion(sector.index = "c")
> circos.text(0.5, 0.5, "first one")
>
> circos.clear()
>
> par(new = TRUE)
> circos.par("canvas.xlim" = c(-1.2, 1), "canvas.ylim" = c(-1.2, 1),
+     start.degree = -45)
> circos.initialize(factors = factors, xlim = c(0, 1))
> circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
> circos.updatePlotRegion(sector.index = "a")
> circos.text(0.5, 0.5, "second one")
> circos.updatePlotRegion(sector.index = "d")
> circos.text(0.5, 0.5, "second one")
>
> circos.clear()
\end{Sinput}
\end{Schunk}

<<label=figseperated, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.par("canvas.xlim" = c(-1, 1.2), "canvas.ylim" = c(-1, 1.2), start.degree = -45)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "b")
circos.text(0.5, 0.5, "first one")
circos.updatePlotRegion(sector.index = "c")
circos.text(0.5, 0.5, "first one")

circos.clear()

par(new = TRUE)
circos.par("canvas.xlim" = c(-1.2, 1), "canvas.ylim" = c(-1.2, 1), start.degree = -45)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "a")
circos.text(0.5, 0.5, "second one")
circos.updatePlotRegion(sector.index = "d")
circos.text(0.5, 0.5, "second one")

circos.clear()
@

\begin{figure}
\begin{center}
<<label=figseperated, fig = TRUE, echo = FALSE>>=
<<figseperated>>
@
\end{center}
\caption{Two seperated circos layouts}
\label{fig:nested}
\end{figure}

\section{High level plotting functions}
With those low level function such as {\tt circos.lines}, {\tt circos.lines},
more high level functions can be easily written. The package provides a high
level function {\tt circos.trackHist} which draws the histogram or the density
distribution of data (figure 14). So users would know how to implement other
high level function to support graphs such as barplot, heatmap, et al. accroding to the source code of {\tt circos.trackHist}.

In figure 13, the first track is histograms in which all the ylim are same.
The second track is histograms in which {\tt force.ylim} is {\tt FALSE}.
The third and the fourth tracks are density distributions in which ylims
are forced same or different.


<<label=fighist, include=FALSE, echo=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
x = rnorm(2600)
factors = sample(letters, 2600, replace = TRUE)
circos.initialize(factors = factors, x = x)
circos.trackHist(factors = factors, x = x, track.height = 0.1, col = "#CCCCCC", border = "#CCCCCC")
circos.trackHist(factors = factors, x = x, force.ylim = FALSE, track.height = 0.1, col = "#CCCCCC", border = "#CCCCCC")
circos.trackHist(factors = factors, x = x, draw.density = TRUE, track.height = 0.1, col = "#CCCCCC", border = "#CCCCCC")
circos.trackHist(factors = factors, x = x, draw.density = TRUE, force.ylim = FALSE, track.height = 0.1, col = "#CCCCCC", border = "#CCCCCC")

circos.clear()

@

\begin{figure}
\begin{center}
<<label=fighist, fig = TRUE, echo = FALSE>>=
<<fighist>>
@
\end{center}
\caption{Drawing histograms}
\label{fig:hist}
\end{figure}

\section{Others}
Sometimes it is very useful to draw something outside the plotting region of cell. The following is a simple
example to illustrate such circumstance (figure 15). The text and the rectangle are all drawn outside the cell.

Since the finnal graph is drawn in the ordinary canvas plotting region, we can add additional graphs through
the traditional way. You can also see how {\tt text} and {\tt legend} work in the following example code.

\begin{Schunk}
\begin{Sinput}
> set.seed(12345)
> par(mar = c(1, 1, 1, 1))
> factors = letters[1:4]
> circos.par("canvas.xlim" = c(-1.5, 1.5), "canvas.ylim" = c(-1.5, 1.5),
+     "gap.degree" = 10)
> circos.initialize(factors = factors, xlim = c(0, 1))
> circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
+     circos.points(1:20/20, 1:20/20)
+ })
> circos.lines(c(1/20, 0.5), c(1/20, 3), sector.index = "d", straight = TRUE)
> circos.text(0.5, 3, "mark", sector.index = "d", adj = c(0.5, 0))
>
> circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
+     circos.points(1:20/20, 1:20/20)
+ })
> circos.rect(-0.2, -1, 1.2, 3, col = "#FF000040", border = NA)
>
> text(0, 0, "this is\nthe center", cex = 1.5)
> legend("bottomleft", pch = 1, legend = "this is the legend")
>
> circos.clear()
\end{Sinput}
\end{Schunk}

<<label=figoutside, include=FALSE, echo=FALSE>>=
library(circlize)
set.seed(12345)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.par("canvas.xlim" = c(-1.5, 1.5), "canvas.ylim" = c(-1.5, 1.5), "gap.degree" = 10)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
	circos.points(1:20/20, 1:20/20)
})
circos.lines(c(1/20, 0.5), c(1/20, 3), sector.index = "d", straight = TRUE)
circos.text(0.5, 3, "mark", sector.index = "d", adj = c(0.5, 0))

circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
	circos.points(1:20/20, 1:20/20)
})
circos.rect(-0.2, -1, 1.2, 3, col = "#FF000040", border = NA)
text(0, 0, "this is\nthe center", cex = 1.5)
legend("bottomleft", pch = 1, legend = "this is the legend")
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figoutside, fig = TRUE, echo = FALSE>>=
<<figoutside>>
@
\end{center}
\caption{Drawing outside the cell}
\label{fig:outside}
\end{figure}

\end{document}
